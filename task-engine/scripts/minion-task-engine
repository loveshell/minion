#!/usr/bin/env python


import base64
import copy
import json
import logging
import optparse
import sys
import uuid

import klein
import zope.interface

from twisted.internet import reactor
from twisted.internet.defer import Deferred
from twisted.internet.defer import DeferredList
from twisted.internet.defer import DeferredSemaphore
from twisted.internet.defer import inlineCallbacks, returnValue
from twisted.internet.task import deferLater
from twisted.web.client import Agent
from twisted.web.http_headers import Headers
from twisted.web.iweb import IBodyProducer
from twisted.internet.defer import succeed
from twisted.web.client import getPage


PLANS = {}

PLANS['tickle'] = {
    'name': 'tickle',
    'description': 'Run basic tests and do a very basic port scan using NMAP.',
    'workflow': [
        {
            'plugin_name': 'minion.plugins.basic.HSTSPlugin',
            'configuration': {
                # No special configuration needed
            }
        },
        {
            'plugin_name': 'minion.plugins.basic.XFrameOptionsPlugin',
            'configuration': {
                # No special configuration needed
            }
        },
        {
            'plugin_name': 'minion.plugins.nmap.NMAPPlugin',
            'configuration': {
                'ports': "U:53,111,137,T:21-25,139,8080,8443"
            }
        }
    ]
}

PLANS['scratch'] = {
    'name': 'scratch',
    'description': 'Run Garmr and do a full port scan using NMAP.',
    'workflow': [
        {
            'plugin_name': 'minion.plugins.garmr.GarmrPlugin',
            'configuration': {
                # No special configuration needed
            }
        },
        {
            'plugin_name': 'minion.plugins.nmap.NMAPPlugin',
            'configuration': {
                # No special configuration needed
            }
        }
    ]
}

PLANS['zap'] = {
    'name': 'zap',
    'description': 'Run ZAP spider and active scanner.',
    'workflow': [
        {
            'plugin_name': 'minion.plugins.zap_plugin.ZAPPlugin',
            'configuration': {
                # No special configuration needed
            }
        }
    ]
}

SCANS = {}

PLUGIN_SERVICE_API = "http://localhost:8181"
PLUGIN_SERVICE_POLL_INTERVAL = 1.0


class Scan:

    def __init__(self, plan, configuration):
        self.plan = plan
        self.configuration = configuration
        self.id = str(uuid.uuid4())
        self.state = 'CREATED'
        self.plugin_configurations = []
        self.semaphore = DeferredSemaphore(1)
        self.plugin_service_api = PLUGIN_SERVICE_API
        self.plugin_sessions = []

    #
    # Return True if all plugins have completed.
    #

    def _all_sessions_are_done(self):
        for session in self.plugin_sessions:
            if session['state'] in ('CREATED', 'STARTED'):
                return False
        return True
    
    #
    # Periodically decide what to do in our workflow. We simply walk
    # over all the plugin sessions part of this scan and see what
    # needs to happen based on their status.
    #

    @inlineCallbacks
    def _periodic_session_task(self):
        logging.debug("Scan._periodic_session_task")
        # Loop over all sessions and figure out what to do next for them. We do only one thing
        # at a time to minimize calls down to the plugin service.
        for session in self.plugin_sessions:            
            # Update the session so that we have the most recent info
            if session['state'] not in ('FINISHED', 'ABORTED', 'TERMINATED'):
                url = "%s/session/%s" % (self.plugin_service_api, session['id'])
                response = yield getPage(url.encode('ascii')).addCallback(json.loads)
                session.update(response['session'])
            # Now decide what to do based on the session state
            if session['state'] == 'CREATED':
                # Start this plugin session
                logging.debug("Scan._periodic_session_task - Going to start " + session['plugin_name'])
                url = self.plugin_service_api + "/session/%s/state" % session['id']
                result = yield getPage(url.encode('ascii'), method='PUT', postdata='START').addCallback(json.loads)
                break
            elif session['state'] in ('STARTED', 'FINISHED') and session.get('_done') != True:
                # If the status is STARTED or FINISHED then collect the results periodically
                logging.debug("Scan._periodic_session_task - Going to get results from " + session['plugin_name'])
                url = self.plugin_service_api + "/session/%s/results" % session['id']
                result = yield getPage(url.encode('ascii')).addCallback(json.loads)
                session['issues'] = result['issues']
                # If the task is finished, and we just grabbed the final results, then mark it as done
                if session['state'] == 'FINISHED':
                    session['_done'] = True                    
                break
        # If we have more work to do then we schedule ourself again.
        if not self._all_sessions_are_done():
            yield deferLater(reactor, PLUGIN_SERVICE_POLL_INTERVAL, self._periodic_session_task)        
        else:
            self.state = 'FINISHED'
    
    #
    # Start the scan. We change the status to STARTED and call our periodic
    # poller which will be responsible for starting the plugins in the right
    # order and determining wether are done executing.
    #

    def start(self):
        self.state = 'STARTED'
        reactor.callLater(PLUGIN_SERVICE_POLL_INTERVAL, self._periodic_session_task)

    #
    # Create a new scan.
    #
    
    @inlineCallbacks
    def create(self):
        # Create plugin sessions
        for step in self.plan['workflow']:
            # Create the plugin configuration by overlaying the default configuration with the given configuration
            configuration = step['configuration']
            configuration.update(self.configuration)
            # Create the pligin session
            url = self.plugin_service_api + "/session/create/%s" % step['plugin_name']
            response = yield getPage(url.encode('ascii'), method='PUT', postdata=json.dumps(configuration)).addCallback(json.loads)
            self.plugin_sessions.append(response['session'])
        summary = { 'id': self.id, 'state': self.state, 'plan': self.plan, 'configuration': self.configuration,
                    'sessions': self.plugin_sessions }
        returnValue(summary)

    #
    # Stop the current scan
    # TODO Kill periodic tasks, etc.
    #

    def stop(self):
        self.state = 'STOPPED'

    #
    # Return a summary of the current plugin. Contains its state,
    # plan, configuration and sessions (including results). So it
    # really is not a summary :-/
    #
    
    def summary(self):
        return { 'id': self.id,
                 'state': self.state,
                 'plan': self.plan,
                 'configuration': self.configuration,
                 'sessions': self.plugin_sessions }

    #
    # Return just the results of the scan. Condensed form of summary()
    # that has an optional since parameter that will let you specify
    # incremental results.
    #

    def results(self, since = 0):
        sessions = []
        for session in self.plugin_sessions:
            issues = []
            for i in session['issues']:
                if i['_time'] > since:
                    issues.append(i)
            s = { 'id': session['id'],
                  'plugin_name': session['plugin_name'],
                  'state': session['state'],
                  'progress': session['progress'],
                  'issues': issues }
            sessions.append(s)
        return { 'id': self.id, 'state': self.state, 'sessions': sessions }


def all_sessions_done(sessions):
    for session in sessions:
        if session['state'] in ('CREATED', 'STARTED'):
            return False
    return True
                 
def parse_token(token):
    return int(base64.b64decode(token))

def generate_token(since, sessions):
    if not all_sessions_done(sessions):
        max_time = since
        for session in sessions:
            issues = []
            for i in session['issues']:
                if i['_time'] > max_time:
                    max_time = i['_time']
        return base64.b64encode(str(max_time))

def jsonify(data):
    return json.dumps(data, sort_keys=True, indent=4) + "\n"


@klein.route('/plans', methods=['GET'])
def get_plans(request):
    plans = [{'name': plan['name'], 'description': plan['description']} for plan in PLANS.values()]
    return jsonify({ 'success': True, 'plans': plans })

@klein.route('/plans/<string:plan_name>', methods=['GET'])
def get_plan(request, plan_name):
    plan = PLANS.get(plan_name)
    if plan is None:
        return jsonify({'success': False, 'error': 'no-such-plan'})
    return jsonify({ 'success': True, 'plan': PLANS[plan_name] })

@klein.route('/scan/create/<string:plan_name>', methods=['PUT'])
def put_scan(request, plan_name):
    plan = PLANS.get(plan_name)
    if plan is None:
        return jsonify({'success': False, 'error': 'no-such-plan'})
    plan = copy.deepcopy(plan)
    configuration = json.loads(request.content.getvalue())
    scan = Scan(plan, configuration)
    SCANS[scan.id] = scan
    return scan.create().addCallback(lambda summary: jsonify({ 'success': True, 'scan': summary }))

@klein.route('/scan/<string:scan_id>')
def get_scan(request, scan_id):
    scan = SCANS.get(scan_id)
    if scan is None:
        return jsonify({'success': False, 'error': 'no-such-scan'})
    return jsonify({ 'success': True, 'scan': scan.summary() })

@klein.route('/scan/<string:scan_id>/state', methods=['POST'])
def post_scan_state(request, scan_id):
    state = request.content.getvalue()
    if state not in ('START', 'STOP'):
        return jsonify({'success': False, 'error': 'unknown-state'})
    scan = SCANS.get(scan_id)
    if scan is None:
        return jsonify({'success': False, 'error': 'no-such-scan'})
    if state == 'START':
        if scan.state != 'CREATED':
            return jsonify({'success': False, 'error': 'unknown-state-transition'})
        scan.start()
    elif state == 'STOP':
        if scan.state != 'STARTED':
            return jsonify({'success': False, 'error': 'unknown-state-transition'})
        scan.stop()
    return jsonify({'success': True})

@klein.route('/scan/<string:scan_id>/results', methods=['GET'])
def get_scan_results(request, scan_id):
    scan = SCANS.get(scan_id)
    if scan is None:
        return jsonify({'success': False, 'error': 'no-such-scan'})
    since = 0
    if 'token' in request.args:
        since = parse_token(request.args['token'][0])
    results = scan.results(since=since)
    return jsonify({ 'success': True,
                     'scan': results,
                     'token': generate_token(since, results['sessions']) })

if __name__ == "__main__":

    parser = optparse.OptionParser()
    parser.add_option("--debug", action="store_true")
    parser.add_option("--address", default="127.0.0.1")
    parser.add_option("--port", default=8282, type="int")

    (options, args) = parser.parse_args()

    level = logging.DEBUG if options.debug else logging.INFO
    logging.basicConfig(level=level, format='%(asctime)s %(levelname).1s %(message)s', datefmt='%y-%m-%d %H:%M:%S')
    logging.info("Starting task-engine on %s:%d" % (options.address,options.port));

    klein.run(options.address, options.port)
